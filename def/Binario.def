DEFINITION MODULE Binario;
(*******************************************************************************
Modulo de definicion de Binario.

Es un arbol binario de busqueda de elementos de tipo TInfo, ordenado segun el
dato de tipo texto.
No hay arbol vacio.

Laboratorio de Programacion 2.
InCo-FI-UDELAR
*******************************************************************************)

FROM Utils IMPORT TCritFiltro, TInfo, TString;
FROM ListaString IMPORT ListaString;

TYPE
   Binario;

   
(*********************)
(*** CONSTRUCTORES ***)
(*********************)

PROCEDURE CrearHoja (i: TInfo): Binario;
(* Crea un arbol formado unicamente por una hoja, cuyo elemento es 'i'. *)


         (* NUEVA *)
PROCEDURE CopiaBinario (a: Binario): Binario;
(* Devuelve una copia de 'a'.
   Esto significa que el arbol resultado debe tener los mismos elementos y
   relaciones padre-hijo que 'a'. 
   El arbol resultado no comparte memoria con 'a'.
   El tiempo de ejecucion es O(n), siendo n = CantidadBinario (a). *)

         (* NUEVA *)
PROCEDURE Balanceado (VAR l: ListaString): Binario;
(* Precondicion: NOT EsVaciaLista (l) y EstaOrdenadaLista (l).
   Devuelve un arbol con un nodo por cada elemento de 'l'. El valor numerico del
   nodo es 0 y el valor de texto es igual al elemento de 'l'.
   El arbol resultado debe estar balanceado.   
   Un arbol esta balanceado si en cada nodo que no es hoja, la cantidad
   de elementos de su subarbol izquierdo es igual a, o 1 mas que, la cantidad 
   de elementos de su subarbol derecho.
   Al finalizar debe haberse liberado toda la memoria asignada a 'l'.    
   El tiempo de ejecucion es O(n . log n), siendo n = CantidadLista (l)
   (ver letra). *)

PROCEDURE InsertarEnBinario (i: TInfo; VAR a: Binario);
(* Inserta 'i' en 'a' respetando el orden del arbol.
   Si en 'a' ya hay un nodo cuyo dato de texto es igual a TextoInfo (i), no se
   hace nada. *)

TYPE
   BoolBinario = RECORD
      CASE hayBinario: BOOLEAN OF
         TRUE: arbol: Binario;
      END;
   END;

   
PROCEDURE Filtrar (clave: CARDINAL; criterio: TCritFiltro; a: Binario):
                                                                  BoolBinario;
(* Si ningun nodo de 'a' cumple la condicion "clave criterio NumeroInfo (nodo)",
   devuelve un elemento cuyo discriminador 'hayBinario' es FALSE.
   En otro caso, devuelve un arbol con los nodos que cumplen la condicion,
   y 'hayBinario' es TRUE.
   En general, en el arbol devuelto se debe mantener las relaciones
   ancestro-descendendiente que hay en 'a'. La excepcion se da cuando un nodo
   no cumple la condicion y tiene descendientes tanto por izquierda como por
   derecha que la cumplen.  En ese caso, para mantener ordenado el
   arbol a devolver se siguen los mismos criterios que en RemoverABB.
   (ver ejemplos en LetraTarea2.pdf)
   El arbol devuelto no comparte memoria con 'a'. 

PROCEDURE Filtrar (clave: CARDINAL; criterio: TCritFiltro; a: Binario): BoolBinario;
(* Si ningun nodo de 'a' cumple la condicion "clave criterio NumeroInfo (nodo)",
   devuelve un elemento cuyo discriminador 'hayBinario' es FALSE.
   En otro caso, devuelve un arbol con los nodos que cumplen la condicion,
   y 'hayBinario' es TRUE.
   En general, en el arbol devuelto se debe mantener las relaciones
   ancestro-descendendiente que hay en 'a'. La excepcion se da cuando un nodo
   no cumple la condicion y tiene descendientes tanto por izquierda como por
   derecha que la cumplen.  En ese caso, para mantener ordenado el
   arbol a devolver se siguen los mismos criterios que en RemoverABB.
   (ver ejemplos en LetraTarea2.pdf)
   El arbol devuelto no comparte memoria con 'a'. *)

   PROCEDURE RemoverNodo (VAR a: Binario; esDerecho: BOOLEAN);
   VAR aNuevo, aMenor: Binario;
   BEGIN
      aNuevo := NIL;
      IF TieneHijoDerecho(a) AND TieneHijoIzquierdo(a) THEN
         (* Busco el nodo para poner en lugar de "borrar" *)
         aNuevo := a^.izquierdo;
         WHILE TieneHijoDerecho(aNuevo) DO
            aNuevo := aNuevo^.derecho;
         END;
         (* Separo "aNuevo" de el arbol *)
         aNuevo^.padre^.derecho := NIL;
         aNuevo^.padre := NIL;
         (* Busco el menor de "aNuevo" *)
         aMenor := aNuevo;
         WHILE TieneHijoIzquierdo(aMenor) DO
            aMenor := aMenor^.izquierdo;
         END;
         (* Muevo la rama izquierda de "a" a la mas izquierda de "aNuevo" *)
         aMenor^.izquierdo := a^.izquierdo;
         a^.izquierdo^.padre := aMenor;
         (* Muevo la rama derecha de "a" a la derecha de "aNuevo" *)
         aNuevo^.derecho := a^.derecho;
         aNuevo^.derecho^.padre := aNuevo;
      ELSIF TieneHijoDerecho(a) THEN
         aNuevo := a^.derecho;
      ELSIF TieneHijoIzquierdo(a) THEN
         aNuevo := a^.izquierdo;
      END;
      IF TieneHijoDerecho(a) OR TieneHijoIzquierdo(a) THEN
         (* Agrego a "aNuevo" en lugar de "a" *)
         aNuevo^.padre := a^.padre;
         IF NOT (aNuevo^.padre = NIL) THEN
            IF esDerecho THEN
               aNuevo^.padre^.derecho := aNuevo;
            ELSE
               aNuevo^.padre^.izquierdo := aNuevo;
            END;
         END;
      END;
     DestruirInfo(a^.info);
     DISPOSE(a);
     (* Fin *)
     a := aNuevo;
   END RemoverNodo;

   PROCEDURE Filtro(clave: CARDINAL; criterio: TCritFiltro; VAR a: Binario; esDerecho: BOOLEAN): BOOLEAN;
   VAR filtro: BOOLEAN;
   BEGIN
      filtro := FALSE;
      IF TieneHijoDerecho(a) AND Filtro(clave, criterio, a^.derecho, TRUE) THEN filtro := TRUE; END;
      IF TieneHijoIzquierdo(a) AND Filtro(clave, criterio, a^.izquierdo, FALSE) THEN filtro := TRUE; END;
      IF ((criterio = FltMayor) AND (clave <= NumeroInfo(a^.info)))
      OR ((criterio = FltMenor) AND (clave >= NumeroInfo(a^.info)))
      OR ((criterio = FltIgual) AND (clave # NumeroInfo(a^.info))) THEN
         RemoverNodo(a, esDerecho);
         filtro := TRUE;
      END;
      RETURN filtro;
   END Filtro;

VAR 
   nuevo : Binario;
   resultado : BoolBinario;
BEGIN

   nuevo := CopiaBinario(a);
   IF NOT EsHoja(nuevo) AND Filtro(clave, criterio, nuevo, FALSE) THEN
      resultado.hayBinario := TRUE;
      resultado.arbol := nuevo;
   ELSE
      DestruirBinario(nuevo);
      resultado.hayBinario := FALSE;
   END;
   RETURN resultado;

END Filtrar;


   *)
   
   
(********************)
(*** DESTRUCTORES ***)
(********************)
   
PROCEDURE RemoverDeBinario (txt: TString; VAR a: Binario);
(* Precondicion: si EsHoja (a), el dato de texto de su elemento no es 'txt'.
   Remueve de 'a' el nodo con el elemento cuyo dato de texto es 'txt'.
   Si ninguno de los nodos de 'a' tiene un elemento cuyo dato de texto sea igual
   a 'txt', no hace nada.
   Si el nodo a eliminar tiene subarboles izquierdo y derecho, debe ser
   sustituido por el mayor del subarbol izquierdo, segun la propiedad de orden
   definida.
   Libera la memoria del nodo y del elemento. *)

PROCEDURE DestruirBinario (VAR a: Binario);
(* Libera la memoria asignada a 'a' y todos sus elementos. *)

(******************)
(*** PREDICADOS ***)
(******************)

PROCEDURE TieneHijoIzquierdo (a: Binario): BOOLEAN;
(* Devuelve TRUE si la raiz de 'a' tiene subarbol izquierdo o FALSE en caso
   contrario. *)

PROCEDURE TieneHijoDerecho (a: Binario): BOOLEAN;
(* Devuelve TRUE si la raiz de 'a' tiene subarbol derecho o FALSE en caso
   contrario. *)

PROCEDURE EsHoja (a: Binario): BOOLEAN;
(* Devuelve TRUE si 'a' esta formado unicamente por una hoja o FALSE en caso
   contrario. *)

(******************)
(*** SELECTORES ***)
(******************)
   
PROCEDURE RaizBinario (a: Binario): TInfo;
(* Devuelve el elemento del nodo que esta en la raiz de 'a'. *)

PROCEDURE Izquierdo (a: Binario): Binario;
(* Precondicion: TieneHijoIzquierdo (a).
   Devuelve el subarbol izquierdo del nodo raiz de 'a'. *)

PROCEDURE Derecho (a: Binario): Binario;
(* Precondicion: TieneHijoDerecho (a).
   Devuelve el subarbol derecho del nodo raiz de 'a'. *)

PROCEDURE AlturaBinario (a: Binario): CARDINAL;
(* Devuelve la altura de 'a'.
   La altura de una hoja es 1. *)

PROCEDURE CantidadBinario (a: Binario): CARDINAL;
(* Devuelve la cantidad de nodos de 'a'. *)

         (* NUEVA *)
PROCEDURE Linealizacion (a: Binario): ListaString;
(* Devuelve una lista con los datos de texto de los nodos de 'a. 
   La lista resultado debe estar en orden lexicografico creciente.
   En la lista resultado la posicion actual debe quedar al inicio.
   El tiempo de ejecucion es O(n), siendo 'n' la cantidad de nodos de 'a'. *)

         (* ANTES EN APLICACIONES *)
PROCEDURE BuscarABB (txt: TString; a: Binario): BoolBinario;
(* Devuelve el subarbol que tiene como raiz al elemento cuyo dato de texto es
   'txt' y el discriminador 'hayBinario' del elemanto devuelto es TRUE.
   Si 'txt' no pertenece a 'a', 'hayBinario' es FALSE. *)
   

(********************)
(****** SALIDA ******)
(********************)

PROCEDURE ImprimirBinario (a: Binario);
(* Imprime en orden inverso.
   La indentacion de cada nodo es su nivel. *)
   
   
   
END Binario.
